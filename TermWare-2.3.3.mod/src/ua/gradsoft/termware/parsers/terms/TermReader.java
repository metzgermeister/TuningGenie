/* Generated By:JavaCC: Do not edit this line. TermReader.java */
package ua.gradsoft.termware.parsers.terms;

import java.io.*;
import java.util.*;
import java.math.*;

import ua.gradsoft.termware.*;
import ua.gradsoft.termware.exceptions.*;
import ua.gradsoft.termware.parsers.terms.util.*;

/**
 * Parser for TermWare language.
 **/
public class TermReader implements TermReaderConstants {

 public TermReader(InputStream in,String fname, int lineCorrection, TermWareInstance instance)
 {
  this(in);
  fname_=fname;
  lineCorrection_=lineCorrection;
  instance_=instance;
  if (instance_==null) {
     throw new RuntimeException("null in instance parameter in TermReader constructor");
  }
 }

 public TermReader(Reader in,String fname, int lineCorrection, TermWareInstance instance)
 {
  this(in);
  fname_=fname;
  lineCorrection_=lineCorrection;
  instance_=instance;
  if (instance_==null) {
     throw new RuntimeException("null in instance parameter in TermReader constructor");
  }
 }


 public static void main(String[] args)
 {
  try {
   TermReader termReader=new TermReader(System.in,"<stdin>");
   for(;;) {
     Term Term = termReader.readStatement();
     Term.print(System.out);
     if (Term.isNil()) break;
   }
  }catch(TermWareException ex){
   System.err.print(ex.getMessage());
  }catch(ParseException ex){
   System.err.print(ex.getMessage());
  }
 }

 public  Term readStatementWrapped() throws TermWareException
 {
  try {
    return readStatement();
  }catch(ParseException ex){
    throw new TermParseException(ex.getMessage());
  }catch(TokenMgrError ex){
    throw new TermParseException(ex.getMessage());
  }
 }

 public void setTermWareInstance(TermWareInstance instance)
 {
  instance_=instance;
 }

 public void setFname(String fname)
 {
  fname_=fname;
 }

 public StringIndex getStringIndex()
 {
   lazyInitXStringIndex();
   return xStringIndex;
 }

 public final boolean eofReached()
   { return eofReached_; }

 private void lazyInitXStringIndex()
  { if (xStringIndex==null) xStringIndex=new StringIndex(); }

 private StringIndex  xStringIndex=null;

 private boolean eofReached_=false;
 private String  fname_="<unknown>";
 private int     line_=1;
 private TermWareInstance instance_;
 private boolean debug_=false;
 private int     lineCorrection_=0;


 Term  create(String name, Term[] body) throws TermWareException
 {
   if (instance_==null) {
       System.err.println("TermReader.create - instance_ is null");
   }
   Term retval=instance_.getTermFactory().createComplexTerm(name,body);
   if (body.length>0) {
     retval=TermHelper.setAttribute(retval,"__BEGIN_LINE__",TermHelper.getAttribute(body[0],"__BEGIN_LINE__"));
     retval=TermHelper.setAttribute(retval,"__END_LINE__",TermHelper.getAttribute(body[body.length-1],"__END_LINE__"));
     retval=TermHelper.setAttribute(retval,"__FILE__",fname_);
   }
   return retval;
 }

 Term  createNil()
 { return instance_.getTermFactory().createNil(); }

 Term  create(String name, Term x1)  throws TermWareException
 {
   Term[] body=new Term[1];
   body[0]=x1;
   return create(name,body);
 }

 Term  create(String name, Term x1,Term x2)  throws TermWareException
 {
   Term[] body=new Term[2];
   body[0]=x1;
   body[1]=x2;
   return create(name,body);
 }

 Term  create(String name, Term x1,Term x2,Term x3)  throws TermWareException
 {
   Term[] body=new Term[3];
   body[0]=x1;
   body[1]=x2;
   body[2]=x3;
   return create(name,body);
 }

 Term  create(String name, Term x1,Term x2,Term x3,Term x4)  throws TermWareException
 {
   Term[] body=new Term[4];
   body[0]=x1;
   body[1]=x2;
   body[2]=x3;
   body[3]=x4;
   return create(name,body);
 }

 Term  create(String name, Term x1,Term x2,Term x3,Term x4,Term x5)  throws TermWareException
 {
   Term[] body=new Term[5];
   body[0]=x1;
   body[1]=x2;
   body[2]=x3;
   body[3]=x4;
   body[4]=x5;
   return create(name,body);
 }


 Term  createSet()  throws TermWareException
 {
  Term[] body=new Term[0];
  return create("set",body);
 }

 Term  createSet(Term[] body)   throws TermWareException
 {
  return create("set",body);
 }

 Term  createSetPattern(Term frs,Term snd)  throws TermWareException
 {
  return create("set_pattern",frs,snd);
 }

 Term  createList(Term[] body)   throws TermWareException
 {
  Term retval = instance_.getTermFactory().createList(body);
   if (body.length>0) {
     retval=TermHelper.setAttribute(retval,"__BEGIN_LINE__",TermHelper.getAttribute(body[0],"__BEGIN_LINE__"));
     retval=TermHelper.setAttribute(retval,"__END_LINE__",TermHelper.getAttribute(body[body.length-1],"__END_LINE__"));
     retval=TermHelper.setAttribute(retval,"__FILE__",fname_);
   }
  return retval;
 }

 Term  createList(List<Term> body)   throws TermWareException
 {
   Term retval=instance_.getTermFactory().createList(body);
   if (body.size()>0) {
     retval=TermHelper.setAttribute(retval,"__BEGIN_LINE__",TermHelper.getAttribute(body.get(0),"__BEGIN_LINE__"));
     retval=TermHelper.setAttribute(retval,"__END_LINE__",TermHelper.getAttribute(body.get(body.size()-1),"__END_LINE__"));
     retval=TermHelper.setAttribute(retval,"__FILE__",fname_);
   }
   return retval;
 }



 Term  addRightAssociativeClause(String clause,Term body,Term termToAppend)  throws TermWareException
 {
  Term curr=body;
  Term prevCurr=null;
  Term retval=null;
  while(curr.getName().equals(clause)) {
      prevCurr=curr;
      curr=curr.getSubtermAt(1);
  }
  if (prevCurr!=null) {
    prevCurr.setSubtermAt(1,create(clause,curr,termToAppend));
    retval=body;
  }else{
    retval=create(clause,body,termToAppend);
  }
  return retval;
 }

 Term mayBeAction(Term t1, Term t2)  throws TermWareException
 {
  if (t2==null) {
    return t1;
  }else{
    return create("action",t1,t2);
  }
 }

/**
 * <code>
 *    statement :  term ";"
 *               |
 *                 term <EOF>
 *               |
 *                 <EOF>
 * </code>
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTerm
 **/
  final public Term readStatement() throws ParseException, TermWareException {
 Term t;
    if (jj_2_1(2)) {
      t = readTerm();
      jj_consume_token(7);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 8:
      case 9:
      case 11:
      case 16:
      case TRUE:
      case FALSE:
      case INTEGER_LITERAL:
      case STRING_LITERAL:
      case DOUBLE_LITERAL:
      case NIL:
      case IDENT:
      case X_LITERAL:
      case PLUS:
      case MINUS:
      case LOGICAL_NOT:
      case BIT_NEGATE:
      case DOT:
      case NAMPERSAND:
        t = readTerm();
        jj_consume_token(0);
    eofReached_=true;
        break;
      case 0:
        jj_consume_token(0);
     eofReached_=true; {if (true) return TermFactory.createNil();}
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
   {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

/**
 * <code>
 *  term : let_term | term_expression0
 * </code>
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readLetTerm
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermExpression0
 **/
  final public Term readTerm() throws ParseException, TermWareException {
 Term t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 8:
      t = readLetTerm();
   {if (true) return t;}
      break;
    case 9:
    case 11:
    case 16:
    case TRUE:
    case FALSE:
    case INTEGER_LITERAL:
    case STRING_LITERAL:
    case DOUBLE_LITERAL:
    case NIL:
    case IDENT:
    case X_LITERAL:
    case PLUS:
    case MINUS:
    case LOGICAL_NOT:
    case BIT_NEGATE:
    case DOT:
    case NAMPERSAND:
      t = readTermExpression0();
   {if (true) return t;}
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * <code>
 *  let_term : "let" term
 * </code> <br>
 * 'let t' is synonim of let(t).
 * default behaviour - add rule t to current ruleset.
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTerm
 **/
  final public Term readLetTerm() throws ParseException, TermWareException {
 Term t1=null;
 Term t2=null;
 Term t3=null;
 Token tk=null;
    tk = jj_consume_token(8);
    if (jj_2_2(3)) {
      jj_consume_token(9);
      t2 = readWhereAssigments();
      jj_consume_token(10);
      t3 = readTerm();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 8:
      case 9:
      case 11:
      case 16:
      case TRUE:
      case FALSE:
      case INTEGER_LITERAL:
      case STRING_LITERAL:
      case DOUBLE_LITERAL:
      case NIL:
      case IDENT:
      case X_LITERAL:
      case PLUS:
      case MINUS:
      case LOGICAL_NOT:
      case BIT_NEGATE:
      case DOT:
      case NAMPERSAND:
        t1 = readTerm();
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
   Term retval=null;
   if (t1!=null) {
     retval=create("let",t1);
   }else{
     retval=create("let",t2,t3);
   }
   {if (true) return retval;}
    throw new Error("Missing return statement in function");
  }

/**
 * <code>
 *  term_expression0 :  term_expression1 [ "[" term_expression1  "]" ] [ "->" term_expression0 [ "[" term_expression1 "]" ] ]
 * </code> <br>
 * Example:
 * <pre>
 *   x->y
 *   fact($x) [|$x==1|] -> 1
 * </pre>
 *TODO:
 * in addition we check (non-grammar) existence of comment to set help for main term of left pattern,
 *  if our grammar is a rule.
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermExpression1
 **/
  final public Term readTermExpression0() throws ParseException, TermWareException {
 Term t1=null;
 Term t2=null;
 Term t3=null;
 Term t4=null;
 Term e1=null;
 Term e2=null;
 Term e3=null;
 Term e4=null;
 Term e5=null;
 ArrayList<Term> elifConditions=null;
 Token op=null;
 Term retval=null;
 Token tkE1Begin=null;
 Token tkE1End=null;
 Token tkE2Begin=null;
 Token tkE2End=null;
 Token tkE3Begin=null;
 Token tkE3End=null;
 Token tkE4Begin=null;
 Token tkE4End=null;
 Token tkE5Begin=null;
 Token tkE5End=null;
 Term  l1=null;
 Token tkL1Begin=null;
 Token tkL1End=null;
 Term  l2=null;
 Token tkL2Begin=null;
 Token tkL2End=null;
 Term  l3=null;
 Token tkL3Begin=null;
 Token tkL3End=null;
 Term  l4=null;
 Token tkL4Begin=null;
 Token tkL4End=null;
 Term  w1=null;
 Token tkW1Begin=null;
 Token tkW1End=null;
 Term  w2=null;
 Token tkW2Begin=null;
 Token tkW2End=null;
 Term  w3=null;
 Token tkW3Begin=null;
 Token tkW3End=null;
 Term  w4=null;
 Token tkW4Begin=null;
 Token tkW4End=null;
    t1 = readTermExpression1();
    if (jj_2_6(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 8:
        tkL1Begin = jj_consume_token(8);
        jj_consume_token(9);
        l1 = readWhereAssigments();
        tkL1End = jj_consume_token(10);
             l1=TermHelper.setAttribute(l1,"__FILE__",fname_);
             l1=TermHelper.setAttribute(l1,"__BEGIN_LINE__",tkL1Begin.beginLine+lineCorrection_);
             l1=TermHelper.setAttribute(l1,"__END_LINE__",tkL1End.endLine+lineCorrection_);
        break;
      default:
        jj_la1[3] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 11:
        tkE1Begin = jj_consume_token(11);
        e1 = readTermExpression1();
        tkE1End = jj_consume_token(12);
             e1=TermHelper.setAttribute(e1,"__FILE__",fname_);
             e1=TermHelper.setAttribute(e1,"__BEGIN_LINE__",tkE1Begin.beginLine+lineCorrection_);
             e1=TermHelper.setAttribute(e1,"__END_LINE__",tkE1End.endLine+lineCorrection_);
        break;
      default:
        jj_la1[4] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 13:
        tkW1Begin = jj_consume_token(13);
        jj_consume_token(9);
        w1 = readWhereAssigments();
        tkW1End = jj_consume_token(10);
             w1=TermHelper.setAttribute(w1,"__FILE__",fname_);
             w1=TermHelper.setAttribute(w1,"__BEGIN_LINE__",tkW1Begin.beginLine+lineCorrection_);
             w1=TermHelper.setAttribute(w1,"__BEGIN_LINE__",tkW1End.endLine+lineCorrection_);
        break;
      default:
        jj_la1[5] = jj_gen;
        ;
      }
      jj_consume_token(LEFT_ARROW);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 8:
        tkL2Begin = jj_consume_token(8);
        jj_consume_token(9);
        l2 = readWhereAssigments();
        tkL2End = jj_consume_token(10);
             l2=TermHelper.setAttribute(l2,"__FILE__",fname_);
             l2=TermHelper.setAttribute(l2,"__BEGIN_LINE__",tkL2Begin.beginLine+lineCorrection_);
             l2=TermHelper.setAttribute(l2,"__END_LINE__",tkL2End.endLine+lineCorrection_);
        break;
      default:
        jj_la1[6] = jj_gen;
        ;
      }
      t2 = readTermExpression1();
      if (jj_2_3(2)) {
        tkE2Begin = jj_consume_token(11);
        e2 = readTermExpression1();
        tkE2End = jj_consume_token(12);
             e2=TermHelper.setAttribute(e2,"__FILE__",fname_);
             e2=TermHelper.setAttribute(e2,"__BEGIN_LINE__",tkE2Begin.beginLine+lineCorrection_);
             e2=TermHelper.setAttribute(e2,"__END_LINE__",tkE2End.endLine+lineCorrection_);
      } else {
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 13:
        tkW2Begin = jj_consume_token(13);
        jj_consume_token(9);
        w2 = readWhereAssigments();
        tkW2End = jj_consume_token(10);
             w2=TermHelper.setAttribute(w2,"__FILE__",fname_);
             w2=TermHelper.setAttribute(w2,"__BEGIN_LINE__",tkW2Begin.beginLine+lineCorrection_);
             w2=TermHelper.setAttribute(w2,"__BEGIN_LINE__",tkW2End.endLine+lineCorrection_);
        break;
      default:
        jj_la1[7] = jj_gen;
        ;
      }
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BIT_OR:
          ;
          break;
        default:
          jj_la1[8] = jj_gen;
          break label_1;
        }
        jj_consume_token(BIT_OR);
        tkE3Begin = jj_consume_token(11);
        e3 = readTermExpression1();
        tkE3End = jj_consume_token(12);
        jj_consume_token(LEFT_ARROW);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 8:
          tkL3Begin = jj_consume_token(8);
          jj_consume_token(9);
          l3 = readWhereAssigments();
          tkL3End = jj_consume_token(10);
                l3=TermHelper.setAttribute(l3,"__FILE__",fname_);
                l3=TermHelper.setAttribute(l3,"__BEGIN_LINE__",tkL3Begin.beginLine+lineCorrection_);
                l3=TermHelper.setAttribute(l3,"__END_LINE__",tkL3End.endLine+lineCorrection_);
          break;
        default:
          jj_la1[9] = jj_gen;
          ;
        }
        t3 = readTermExpression1();
        if (jj_2_4(2)) {
          tkE4Begin = jj_consume_token(11);
          e4 = readTermExpression1();
          tkE4End = jj_consume_token(12);
        } else {
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 13:
          tkW3Begin = jj_consume_token(13);
          jj_consume_token(9);
          w3 = readWhereAssigments();
          tkW3End = jj_consume_token(10);
             w3=TermHelper.setAttribute(w3,"__FILE__",fname_);
             w3=TermHelper.setAttribute(w3,"__BEGIN_LINE__",tkW3Begin.beginLine+lineCorrection_);
             w3=TermHelper.setAttribute(w3,"__BEGIN_LINE__",tkW3End.endLine+lineCorrection_);
          break;
        default:
          jj_la1[10] = jj_gen;
          ;
        }
             if (elifConditions==null) {
               elifConditions=new ArrayList<Term>();
             }
             Term elifTerm=null;
             if (e4==null) {
               if (l3!=null) {
                   t3=create("let",l3,t3);
               }
               if (w3!=null) {
                   t3=create("where",t3,w3);
               }
               elifTerm=create("elif",e3,t3);
               elifTerm=TermHelper.setAttribute(elifTerm,"__FILE__",fname_);
               elifTerm=TermHelper.setAttribute(elifTerm,"__BEGIN_LINE__",tkE3Begin.beginLine+lineCorrection_);
               elifTerm=TermHelper.setAttribute(elifTerm,"__END_LINE__",tkE3End.beginLine+lineCorrection_);
             }else{
               Term action=create("action",t3,e4);
               action=TermHelper.setAttribute(action,"__FILE__",fname_);
               action=TermHelper.setAttribute(action,"__BEGIN_LINE__",tkE4Begin.beginLine+lineCorrection_);
               action=TermHelper.setAttribute(action,"__END_LINE__",tkE4End.beginLine+lineCorrection_);
               if (l3!=null) {
                 action=create("let",l3,action);
               }
               if (w3!=null) {
                 action=create("where",action,w3);
               }
               elifTerm=create("elif",e3,action);
               elifTerm=TermHelper.setAttribute(elifTerm,"__FILE__",fname_);
               elifTerm=TermHelper.setAttribute(elifTerm,"__BEGIN_LINE__",tkE3Begin.beginLine+lineCorrection_);
               elifTerm=TermHelper.setAttribute(elifTerm,"__END_LINE__",tkE3End.beginLine+lineCorrection_);
             }
             elifConditions.add(elifTerm);
             e3=null;
             t3=null;
             e4=null;
             l3=null;
             w3=null;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 14:
        jj_consume_token(14);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 8:
          tkL4Begin = jj_consume_token(8);
          jj_consume_token(9);
          l4 = readWhereAssigments();
          tkL4End = jj_consume_token(10);
                     l4=TermHelper.setAttribute(l4,"__FILE__",fname_);
                     l4=TermHelper.setAttribute(l4,"__BEGIN_LINE__",tkL4Begin.beginLine+lineCorrection_);
                     l4=TermHelper.setAttribute(l4,"__END_LINE__",tkL4End.endLine+lineCorrection_);
          break;
        default:
          jj_la1[11] = jj_gen;
          ;
        }
        t4 = readTermExpression1();
        if (jj_2_5(2)) {
          tkE5Begin = jj_consume_token(11);
          e5 = readTermExpression1();
          tkE5End = jj_consume_token(12);
                                    e5=TermHelper.setAttribute(e5,"__FILE__",fname_);
                                    e5=TermHelper.setAttribute(e5,"__BEGIN_LINE__",tkE5Begin.beginLine+lineCorrection_);
                                    e5=TermHelper.setAttribute(e5,"__END_LINE__",tkE5End.beginLine+lineCorrection_);
        } else {
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 13:
          tkW4Begin = jj_consume_token(13);
          jj_consume_token(9);
          w4 = readWhereAssigments();
          tkW4End = jj_consume_token(10);
                                w4=TermHelper.setAttribute(w4,"__FILE__",fname_);
                                w4=TermHelper.setAttribute(w4,"__BEGIN_LINE__",tkW4Begin.beginLine+lineCorrection_);
                                w4=TermHelper.setAttribute(w4,"__BEGIN_LINE__",tkW4End.endLine+lineCorrection_);
          break;
        default:
          jj_la1[12] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[13] = jj_gen;
        ;
      }
    } else {
      ;
    }
   if (e1==null && t2==null) {
     retval=t1;
   }else if (e1==null && t2!=null && e2==null && elifConditions==null && t4==null) {
     if (l1!=null) {
        t1=create("let",l1,t1);
     }
     if (w1!=null) {
        t1=create("where",t1,w1);
     }
     if (l2!=null) {
        t2=create("let",l2,t2);
     }
     if (w2!=null) {
        t2=create("where",t2,w2);
     }
     retval=create("rule",t1,t2);
   }else if (e1==null && t2!=null && e2==null && elifConditions==null && t4!=null) {
     // t1 -> t2 !-> t4
     {if (true) throw new AssertException("Invalid construction: t  -> t1 !-> t2 ");}
   }else if (e1==null && t2!=null && e2==null && elifConditions!=null) {
     {if (true) throw new AssertException("Invalid construction: t  -> t1 | [p] -> t2 ");}
   }else if (e1==null && t2!=null && e2!=null && elifConditions==null && t4==null) {
     Term action_term=create("action",t2,e2);
     if (l2!=null) {
        action_term=create("let",l2,action_term);
     }
     if (w2!=null) {
        action_term=create("where",action_term,w2);
     }
     if (l1!=null) {
        t1=create("let",l1,t1);
     }
     if (w1!=null) {
        t1=create("where",t1,w1);
     }
     retval=create("rule",t1,action_term);
   }else if (e1==null && t2!=null && e2!=null && elifConditions==null && t4!=null) {
     {if (true) throw new AssertException("Invalid construction: t  -> t1 [a] |-> t2 ");}
   }else if (e1==null && t2!=null && e2!=null && elifConditions!=null ) {
     {if (true) throw new AssertException("Invalid construction: t  -> t1 [a] | [p] -> t2 ");}
   }else if (e1!=null && t2==null && e2==null) {
     {if (true) throw new AssertException("Impossible grammar construction: x [p] ");}
     // 
     // this is legal from grammar point of view, but have no rewriting
     //  semantics.
   }else if (e1!=null && t2==null && e2!=null) {
     // impossible  
     {if (true) throw new AssertException("Impossible grammar construction: t[x]->[y]");}
   }else if (e1!=null && t2!=null && elifConditions==null && t4==null) {
     if (l1!=null) {
        t1=create("let",l1,w1);
     }
     if (w1!=null) {
        w1=create("where",t1,w1);
     }
     Term mayBeAction=mayBeAction(t2,e2);
     if (l2!=null) {
       mayBeAction=create("let",l2,mayBeAction);
     }
     if (w2!=null) {
       mayBeAction=create("where",mayBeAction,w2);
     }
     retval=create("if_rule",t1,e1,mayBeAction);
   }else if (e1!=null && t2!=null && elifConditions==null && t4!=null) {
     Term mba1=mayBeAction(t2,e2);
     if (l2!=null) {
       mba1=create("let",l2,mba1);
     }
     if (w2!=null) {
       mba1=create("where",mba1,w2);
     }
     Term mba2=mayBeAction(t4,e5);
     if (l4!=null) {
       mba2=create("let",l4,mba2);
     }
     if (w4!=null) {
       mba2=create("where",mba2,w4);
     }
     if (l1!=null) {
       t1=create("let",l1,t1);
     }
     if (w1!=null) {
       t1=create("where",t1,w1);
     }
     retval=create("if_rule",t1,e1,mba1,createNil(),mba2);
   }else if (e1!=null && t2!=null && elifConditions!=null && t4==null) {
     Term mba=mayBeAction(t2,e2);
     if (l2!=null) {
       mba=create("where",mba,l2);
     }
     if (w2!=null) {
       mba=create("where",mba,w2);
     }
     Term elifs=createList(elifConditions);
     if (l1!=null) {
       t1=create("let",l1,t1);
     }
     if (w1!=null) {
       t1=create("where",t1,w1);
     }
     retval=create("if_rule",t1,e1,mba,elifs);
   }else if (e1!=null && t2!=null && elifConditions!=null && t4!=null) {
     Term mba1=mayBeAction(t2,e2);
     if (l2!=null) {
         mba1=create("let",l2,mba1);
     }
     if (w2!=null) {
         mba1=create("where",mba1,w2);
     }
     Term mba2=mayBeAction(t4,e5);
     if (l4!=null) {
         mba2=create("let",l4,mba2);
     }
     if (w4!=null) {
        mba2=create("where",mba2,w4);
     }
     Term elifs=createList(elifConditions);
     retval=create("if_rule",t1,e1,mba1,elifs,mba2);
   }else{
     {if (true) throw new AssertException("Impossible grammar construction");}
   }
   Term commentAttribute=TermHelper.getAttribute(t1,"comment");
   if (!commentAttribute.isNil()) {
     retval=TermHelper.setAttribute(retval,"comment",commentAttribute);
   }
   {if (true) return retval;}
    throw new Error("Missing return statement in function");
  }

  final public Term readTermExpressionWhere() throws ParseException, TermWareException {
 Term t1=null;
 Term t2=null;
    t1 = readTermExpression1();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 13:
      jj_consume_token(13);
      jj_consume_token(9);
      t2 = readWhereAssigments();
      jj_consume_token(10);
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
    if (t2==null) {
      {if (true) return t1;}
    }else{
      {if (true) return create("where",t1,t2);}
    }
    throw new Error("Missing return statement in function");
  }

  final public Term readWhereAssigments() throws ParseException, TermWareException {
  Term tx1;
  Term tx2;
  Term te1;
  Term te2;
  LinkedList<Term> assigments=null;
    tx1 = readX();
    jj_consume_token(15);
    te1 = readTermExpression0();
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[15] = jj_gen;
        break label_2;
      }
      jj_consume_token(COMMA);
      tx2 = readX();
      jj_consume_token(15);
      te2 = readTermExpression0();
                                                if (assigments==null) {
                                                   assigments=new LinkedList<Term>();
                                                }
                                                assigments.addLast(create("pair",tx2,te2));
    }
     if (assigments==null) {
         assigments=new LinkedList<Term>();
     }
     assigments.addFirst(create("pair",tx1,te1));
     {if (true) return createList(assigments);}
    throw new Error("Missing return statement in function");
  }

/**
 * <code>
 *  term_expression1 :  term_expression2 [ "?" term_expression1 ":" term_expression1 ]
 * </code>
 *<br>
 * Example:<br>
 * <pre>
 *    x ? y : z
 * </pre>
 *  is synonim for if(x,y,z)
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermExpression1
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermExpression2
 **/
  final public Term readTermExpression1() throws ParseException, TermWareException {
 Term t1=null;
 Term t2=null;
 Term t3=null;
 Token op=null;
 Term retval=null;
    t1 = readTermExpression2();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUESTION:
      op = jj_consume_token(QUESTION);
      t2 = readTermExpression1();
      jj_consume_token(TWO_DOTS);
      t3 = readTermExpression1();
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
   if (t2==null)
     retval=t1;
   else {
     retval=create("if",t1,t2,t3);
     Term commentAttribute=TermHelper.getAttribute(t1,"comment");
     if (!commentAttribute.isNil()) {
         retval=TermHelper.setAttribute(retval,"comment",commentAttribute);
     }
   }
   {if (true) return retval;}
    throw new Error("Missing return statement in function");
  }

/**
 * <code>
 *  term_expression2 :  term_expression3 [ "||" term_expression2 ]
 * </code>
 *<br>
 *
 *<ul>
 * <li> x || y is synonim for logical_or(x,y) </li>
 *<ul>
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermExpression2
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermExpression3
 **/
  final public Term readTermExpression2() throws ParseException, TermWareException {
 Term t1=null;
 Term t2=null;
 Term t3=null;
 Token op=null;
 Term retval=null;
    t1 = readTermExpression3();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOGICAL_OR:
      op = jj_consume_token(LOGICAL_OR);
      t2 = readTermExpression2();
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
   if (t2==null)
     retval=t1;
   else {
     retval=create("logical_or",t1,t2);
     Term commentAttribute=TermHelper.getAttribute(t1,"comment");
     if (!commentAttribute.isNil()) {
         retval=TermHelper.setAttribute(retval,"comment",commentAttribute);
     }
     retval=TermHelper.setAttribute(retval,"__LINE__",op.beginLine+lineCorrection_);
   }
   {if (true) return retval;}
    throw new Error("Missing return statement in function");
  }

/**
 * <code>
 *  term_expression3 :  term_expression4 [ "&&" term_expression3 ]
 * </code>
 *<br>
 *
 *<ul>
 * <li> x && y is synonim for logical_and(x,y) </li>
 *</ul>
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermExpression3
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermExpression4
 **/
  final public Term readTermExpression3() throws ParseException, TermWareException {
 Term t1=null;
 Term t2=null;
 Token op=null;
 Term retval=null;
    t1 = readTermExpression4();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOGICAL_AND:
      op = jj_consume_token(LOGICAL_AND);
      t2 = readTermExpression3();
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
   if (t2==null)
     retval=t1;
   else {
     retval=create("logical_and",t1,t2);
     Term commentAttribute=TermHelper.getAttribute(t1,"comment");
     if (!commentAttribute.isNil()) {
         retval=TermHelper.setAttribute(retval,"comment",commentAttribute);
     }
     retval=TermHelper.setAttribute(retval,"__LINE__",op.beginLine+lineCorrection_);
   }
   {if (true) return retval;}
    throw new Error("Missing return statement in function");
  }

/**
 * <code>
 *  term_expression4 :  term_expression5 
 * </code>
 *<br>
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermExpression4
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermExpression5
 **/
  final public Term readTermExpression4() throws ParseException, TermWareException {
 Term t1=null;
 Term t2=null;
 String op=null;
 Term retval=null;
    t1 = readTermExpression5();
   if (t2==null)
     retval=t1;
   else {
     retval=create("bit_or",t1,t2);
     Term commentAttribute=TermHelper.getAttribute(t1,"comment");
     if (!commentAttribute.isNil()) {
         retval=TermHelper.setAttribute(retval,"comment",commentAttribute);
     }
   }
   {if (true) return retval;}
    throw new Error("Missing return statement in function");
  }

/**
 * <code>
 *  term_expression5 :  term_expression6 [ "&" term_expression5 ]
 * </code>
 * <br>
 *<ul>
 * <li> <code> x & y </code> is synonim for bit_and(x,y) </li>
 *</ul>
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermExpression5
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermExpression6
 **/
  final public Term readTermExpression5() throws ParseException, TermWareException {
 Term t1=null;
 Term t2=null;
 Token op=null;
 Term retval=null;
    t1 = readTermExpression6();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BIT_AND:
      op = jj_consume_token(BIT_AND);
      t2 = readTermExpression5();
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
   if (t2==null) {
     retval=t1;
   }else{
     retval=create("bit_and",t1,t2);
     Term commentAttribute=TermHelper.getAttribute(t1,"comment");
     if (!commentAttribute.isNil()) {
         retval=TermHelper.setAttribute(retval,"comment",commentAttribute);
     }
     retval=TermHelper.setAttribute(retval,"__LINE__",op.beginLine+lineCorrection_);
   }
   {if (true) return retval;}
    throw new Error("Missing return statement in function");
  }

/**
 * <code>
 *  term_expression6 :  term_expression7 [ ( "==" | "!=" ) term_expression7 ]
 * </code> 
 *<br>
 *
 *<ul>
 * <li> x == y is synonim for eq(x,y) </li>
 * <li> x != y is synonim for neq(x,y) </li>
 *</ul>
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermExpression7
 **/
  final public Term readTermExpression6() throws ParseException, TermWareException {
 Term t1=null;
 Term t2=null;
 Token op=null;
 Term retval=null;
    t1 = readTermExpression7();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQ:
    case NEQ:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
        op = jj_consume_token(EQ);
        break;
      case NEQ:
        op = jj_consume_token(NEQ);
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      t2 = readTermExpression7();
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
   if (t2==null)
     retval=t1;
   else {
     if (op.kind==EQ) {
         retval=create("eq",t1,t2);
     }else{
         retval=create("neq",t1,t2);
     }
     Term commentAttribute=TermHelper.getAttribute(t1,"comment");
     if (!commentAttribute.isNil()) {
         retval=TermHelper.setAttribute(retval,"comment",commentAttribute);
     }
     retval=TermHelper.setAttribute(retval,"__LINE__",op.beginLine+lineCorrection_);
   }
   {if (true) return retval;}
    throw new Error("Missing return statement in function");
  }

/**
 * <code>
 *  term_expression7 :  term_expression8 [ ( "<" | ">" | "<=" | ">=" | "=>" | "in" ) term_expression8 ]
 * </code>
 * <br>
 *
 * <ul>
 * <li> x < y is synonim for less(x,y) </li>
 * <li> x > y is synonim for greater(x,y) </li>
 * <li> x <= y is synonim for less_eq(x,y) </li>
 * <li> x >= y is synonim for greater_eq(x,y) </li>
 * <li> x => y is synonim for eq_greater(x,y) </li>
 * <li> x in y is synonim for  _in(x,y) </li>
 * </ul>
 *
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermExpression8
 **/
  final public Term readTermExpression7() throws ParseException, TermWareException {
 Term t1=null;
 Term t2=null;
 Token op=null;
 Term retval=null;
    t1 = readTermExpression8();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IN:
    case LESS:
    case GREATER:
    case LESS_EQ:
    case GREATER_EQ:
    case EQ_GREATER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LESS:
        op = jj_consume_token(LESS);
        break;
      case GREATER:
        op = jj_consume_token(GREATER);
        break;
      case LESS_EQ:
        op = jj_consume_token(LESS_EQ);
        break;
      case GREATER_EQ:
        op = jj_consume_token(GREATER_EQ);
        break;
      case EQ_GREATER:
        op = jj_consume_token(EQ_GREATER);
        break;
      case IN:
        op = jj_consume_token(IN);
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      t2 = readTermExpression8();
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
   if (t2==null) {
     retval=t1;
   } else {
     switch(op.kind) {
       case LESS:
         retval=create("less",t1,t2);
         break;
       case GREATER:
         retval=create("greater",t1,t2);
         break;
       case LESS_EQ:
         retval=create("less_eq",t1,t2);
         break;
       case GREATER_EQ:
         retval=create("greater_eq",t1,t2);
         break;
       case EQ_GREATER:
         retval=create("eq_greater",t1,t2);
         break;
       case IN:
         retval=create("_in",t1,t2);
         break;
       default:
         {if (true) throw new AssertException("unknown binary operation");}
     }
     Term commentAttribute=TermHelper.getAttribute(t1,"comment");
     if (!commentAttribute.isNil()) {
         retval=TermHelper.setAttribute(retval,"comment",commentAttribute);
     }
     retval=TermHelper.setAttribute(retval,"__LINE__",op.beginLine+lineCorrection_);
   }
   {if (true) return retval;}
    throw new Error("Missing return statement in function");
  }

/**
 * <code>
 *  term_expression8 :  term_expression9 ( ( "<<" | ">>" ) term_expression9 )*
 * </code>
 * <br>
 *
 * <ul>
 * <li> <code> x << y </code> is synonim for left_shift(x,y) </li>
 * <li> <code> x >> y </code> is synonim for right_shift(x,y) </li>
 * </ul>
 *
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermExpression9
 **/
  final public Term readTermExpression8() throws ParseException, TermWareException {
 Term t1=null;
 Term t2=null;
 Term t3=null;
 String op=null;
 Token tkOp=null;
 Term retval=null;
    t1 = readTermExpression9();
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_SHIFT:
      case RIGHT_SHIFT:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_SHIFT:
        tkOp = jj_consume_token(LEFT_SHIFT);
                                  op="left_shift";
        break;
      case RIGHT_SHIFT:
        tkOp = jj_consume_token(RIGHT_SHIFT);
                                  op="right_shift";
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      t2 = readTermExpression9();
                              if (t3==null) {
                                 t3=create(op,t1,t2);
                                 t3=TermHelper.setAttribute(t3,"__LINE__",tkOp.beginLine+lineCorrection_);
                              } else {
                                 Term t3p = t3;
                                 t3=create(op,t3p,t2);
                                 t3=TermHelper.setAttribute(t3,"__LINE__",tkOp.beginLine+lineCorrection_);
                              }
    }
   if (t2==null) {
     retval=t1;
   } else {
     retval=t3;
     Term commentAttribute=TermHelper.getAttribute(t1,"comment");
     if (!commentAttribute.isNil()) {
         retval=TermHelper.setAttribute(retval,"comment",commentAttribute);
     }
   }
   {if (true) return retval;}
    throw new Error("Missing return statement in function");
  }

/**
 * <code>
 *  term_expression9 :  term_expression10 ( ( "+" | "-" ) term_expression10 )*
 * </code>
 * <br>
 *
 * <ul>
 * <li> <code> x + y </code> is synonim for plus(x,y) </li>
 * <li> <code> x - y </code> is synonim for minus(x,y) </li>
 * </ul>
 *
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermExpression10
 *TODO: commentAttribute.
 **/
  final public Term readTermExpression9() throws ParseException, TermWareException {
 Term t1=null;
 Term t2=null;
 Term t3=null;
 String op=null;
 Token tkOp=null;
    t1 = readTermExpression10();
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[26] = jj_gen;
        break label_4;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        tkOp = jj_consume_token(PLUS);
                                  op="plus";
        break;
      case MINUS:
        tkOp = jj_consume_token(MINUS);
                                  op="minus";
        break;
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      t2 = readTermExpression10();
                              if (t3==null) {
                                 t3=create(op,t1,t2);
                                 t3=TermHelper.setAttribute(t3,"__LINE__",tkOp.beginLine+lineCorrection_);
                              } else {
                                 Term t3p=t3;
                                 t3=create(op,t3p,t2);
                                 t3=TermHelper.setAttribute(t3,"__LINE__",tkOp.beginLine+lineCorrection_);
                              }
    }
   if (t2==null)
     {if (true) return t1;}
   else
     {if (true) return t3;}
    throw new Error("Missing return statement in function");
  }

/**
 * <code>
 *  term_expression10 :  term_expression11 ( ( "*" | "/" | "%" ) term_expression11 )*
 * </code>
 * <br>
 *
 * <ul>
 * <li> <code> x * y </code> is synonim for multiply(x,y) </li>
 * <li> <code> x / y </code> is synonim for divide(x,y) </li>
 * <li> <code> x % y </code> is synonim for mod(x,y) </li>
 * </ul>
 *
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermExpression11
 **/
  final public Term readTermExpression10() throws ParseException, TermWareException {
 Term t1=null;
 Term t2=null;
 Term t3=null;
 String op=null;
 Token tkOp=null;
    t1 = readTermExpression11();
    label_5:
    while (true) {
      if (jj_2_7(2)) {
        ;
      } else {
        break label_5;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLY:
        tkOp = jj_consume_token(MULTIPLY);
                                  op="multiply";
        break;
      case DIVIDE:
        tkOp = jj_consume_token(DIVIDE);
                                  op="divide";
        break;
      case MOD:
        tkOp = jj_consume_token(MOD);
                                  op="mod";
        break;
      default:
        jj_la1[28] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      t2 = readTermExpression11();
                              if (t3==null) {
                                 t3=create(op,t1,t2);
                                 t3=TermHelper.setAttribute(t3,"__LINE__",tkOp.beginLine+lineCorrection_);
                              } else {
                                 Term t3p=t3;
                                 t3=create(op,t3p,t2);
                                 t3=TermHelper.setAttribute(t3,"__LINE__",tkOp.beginLine+lineCorrection_);
                              }
    }
   if (t2==null)
     {if (true) return t1;}
   else
     {if (true) return t3;}
    throw new Error("Missing return statement in function");
  }

/**
 * <code>
 *  term_expression11 : ( [ "+" | "-" | "!" | "~" ] term_expression10 )
 *                     |
 *                       term_expression12
 * </code>
 * <br>
 *
 * <ul>
 * <li> <code> +x </code> is synonim for plus(x) </li>
 * <li> <code> -x </code> is synonim for minus(x) </li>
 * <li> <code> !x </code> is synonim for logical_not(x) </li>
 * <li> <code> ~x </code> is synonim for bit_negate(x) </li>
 * </ul>
 *
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermExpression10
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermExpression12
 **/
  final public Term readTermExpression11() throws ParseException, TermWareException {
 Term t1;
 Token op;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
    case LOGICAL_NOT:
    case BIT_NEGATE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        op = jj_consume_token(PLUS);
        break;
      case MINUS:
        op = jj_consume_token(MINUS);
        break;
      case LOGICAL_NOT:
        op = jj_consume_token(LOGICAL_NOT);
        break;
      case BIT_NEGATE:
        op = jj_consume_token(BIT_NEGATE);
        break;
      default:
        jj_la1[29] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      t1 = readTermExpression10();
     Term retval=null;
     switch(op.kind) {
       case PLUS:
         if (t1.isInt() || t1.isDouble()) {
            retval=t1;
         }else{
            retval=create("plus",t1);
            retval=TermHelper.setAttribute(retval,"__LINE__",op.beginLine+lineCorrection_);
         }
         break;
       case MINUS:
         if (t1.isInt()) {
           retval=instance_.getTermFactory().createInt(-t1.getInt());
         }else if (t1.isDouble()) {
           retval=instance_.getTermFactory().createDouble(-t1.getDouble());
         }else{
           retval=create("minus",t1);
           retval=TermHelper.setAttribute(retval,"__LINE__",op.beginLine+lineCorrection_);
         }
         break;
       case LOGICAL_NOT:
         retval=create("logical_not",t1);
         retval=TermHelper.setAttribute(retval,"__LINE__",op.beginLine+lineCorrection_);
         break;
       case BIT_NEGATE:
         retval=create("bit_negate",t1);
         retval=TermHelper.setAttribute(retval,"__LINE__",op.beginLine+lineCorrection_);
         break;
       default:
         {if (true) throw new AssertException("unknown unary operation");}
     }
     {if (true) return retval;}
      break;
    case 9:
    case 11:
    case 16:
    case TRUE:
    case FALSE:
    case INTEGER_LITERAL:
    case STRING_LITERAL:
    case DOUBLE_LITERAL:
    case NIL:
    case IDENT:
    case X_LITERAL:
    case DOT:
    case NAMPERSAND:
      t1 = readTermExpression12();
     {if (true) return t1;}
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * <code>
 *  term_expression12 : term_expression13 ( "." term_expression13 )*
 * </code>
 * <br>
 *
 * <ul>
 * <li> <code> x.y </code> is synonim for apply(x,y) </li>
 * </ul>
 *
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermExpression13
 **/
  final public Term readTermExpression12() throws ParseException, TermWareException {
 Term t1=null;
 Term t2=null;
 Term t3=null;
 Token firstDot=null;
 Token secondDot=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      firstDot = jj_consume_token(DOT);
      break;
    default:
      jj_la1[31] = jj_gen;
      ;
    }
    t1 = readTermExpression13();
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        ;
        break;
      default:
        jj_la1[32] = jj_gen;
        break label_6;
      }
      secondDot = jj_consume_token(DOT);
      t2 = readTermExpression13();
                               if (t3==null) {
                                 t3=create("apply",t1,t2);
                                 t3=TermHelper.setAttribute(t3,"__LINE__",secondDot.beginLine+lineCorrection_);
                               } else {
                                 Term t3p=t3;
                                 t3=create("apply",t3p,t2);
                                 t3=TermHelper.setAttribute(t3,"__LINE__",secondDot.beginLine+lineCorrection_);
                               }
    }
    if (firstDot==null) {
     if (t3==null) {
      {if (true) return t1;}
     } else {
      {if (true) return t3;}
     }
    }else{
     if (t3==null) {
        Term retval=create("jcall",t1);
        retval=TermHelper.setAttribute(retval,"__LINE__",firstDot.beginLine+lineCorrection_);
        {if (true) return retval;}
     }else{
        Term retval=create("jcall",t3);
        retval=TermHelper.setAttribute(retval,"__LINE__",firstDot.beginLine+lineCorrection_);
        {if (true) return retval;}
     }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * <code>
 *  term_expression13 : term_expression_14 [ ".." ( x ) ]
 * </code>
 * <br>
 *
 *
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermExpression14
 **/
  final public Term readTermExpression13() throws ParseException, TermWareException {
 Term t1;
 Term t2=null;
 Token op=null;
    t1 = readTermExpression14();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ARGS_DOTS:
      op = jj_consume_token(ARGS_DOTS);
      jj_consume_token(9);
      t2 = readX();
      jj_consume_token(10);
      break;
    default:
      jj_la1[33] = jj_gen;
      ;
    }
     if (t2==null) {
        {if (true) return t1;}
     } else {
        Term retval = create("args_pattern",t1,t2);
        retval=TermHelper.setAttribute(retval,"__LINE__",op.beginLine+lineCorrection_);
        {if (true) return retval;}
     }
    throw new Error("Missing return statement in function");
  }

/**
 * <code>
 *  term_expression14 : term_expression_last
 * </code>
 * <br>
 *
 *
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermExpressionLast
 **/
  final public Term readTermExpression14() throws ParseException, TermWareException {
 Term t1;
 HashMap<String,Term> attributes=null;
 Token tk;
 Term  a;
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NAMPERSAND:
        ;
        break;
      default:
        jj_la1[34] = jj_gen;
        break label_7;
      }
      jj_consume_token(NAMPERSAND);
      tk = jj_consume_token(IDENT);
      jj_consume_token(9);
      a = readTerm();
      jj_consume_token(10);
     if (attributes==null) {
       attributes=new HashMap<String,Term>();
     }
     attributes.put(tk.image,a);
    }
    t1 = readTermExpression15();
     if (attributes!=null) {
        for(Map.Entry<String,Term> e: attributes.entrySet()) {
          t1=TermHelper.setAttribute(t1,e.getKey(),e.getValue());
        }
     }
     {if (true) return t1;}
    throw new Error("Missing return statement in function");
  }

/**
 * <code>
 *  term_expression15 : term_expression_last
 * </code>
 * <br>
 *
 *
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermExpressionLast
 **/
  final public Term readTermExpression15() throws ParseException, TermWareException {
 Term t1;
    t1 = readTermExpressionLast();
     {if (true) return t1;}
    throw new Error("Missing return statement in function");
  }

/**
 * <code>
 *  term_expression_last : scoped_name [ term_args ] | primitive | x | "(" term ")" | "{" term set_tail "}" | "{" "}" | "[" term_comma_list "]"
 * </code>
 * <br>
 *
 * <ul>
 * <li> <code> { x1, x2, .. xn } </code> is synonim for set(x1,..xn) </li>
 * <li> <code> { x, $x } </code> is synonim for set_pattern(x,$x) </li>
 * <li> <code> {  } </code> is synonim for empty set </li>
 * <li> <code> [ x1, x2, .. xN ] </code> is synonim for cons(x1,cons(x2, ...cons(xN-1,xN)...)) </li>
 * </ul>
 *
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readScopedName
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermArgs
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readPrimitive
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readX
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTerm
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readPatternTail
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermCommaList
 **/
  final public Term readTermExpressionLast() throws ParseException, TermWareException {
 Term retval;
 Term termName;
 Term[]  termBody=null;
 Term t1=null;
 Term t2=null;
 Token tk1=null;
 Token tk2=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENT:
      termName = readScopedName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 9:
        termBody = readTermArgs();
        break;
      default:
        jj_la1[35] = jj_gen;
        ;
      }
    if (termBody==null) { // atom  or name
      {if (true) return termName;}
    }else{
      if (termName.isAtom()) {
        retval = create(termName.getName(), termBody);
        retval=TermHelper.setAttribute(retval,"__FILE__",fname_);
        retval=TermHelper.setAttribute(retval,"__BEGIN_LINE__",TermHelper.getAttribute(termName,"__BEGIN_LINE__"));
        if (termBody.length!=0) {
           retval=TermHelper.setAttribute(retval,"__END_LINE__",TermHelper.getAttribute(termBody[termBody.length-1],"__END_LINE__"));
        }else{
          retval=TermHelper.setAttribute(retval,"__END_LINE__",TermHelper.getAttribute(termName,"__END_LINE__"));
        }
        {if (true) return retval;}
      }else{
        {if (true) throw new AssertException("Scoped name used as functional name");}
      }
    }
      break;
    case TRUE:
    case FALSE:
    case INTEGER_LITERAL:
    case STRING_LITERAL:
    case DOUBLE_LITERAL:
    case NIL:
      retval = readPrimitive();
    {if (true) return retval;}
      break;
    case X_LITERAL:
      retval = readX();
    {if (true) return retval;}
      break;
    case 9:
      tk1 = jj_consume_token(9);
      retval = readTerm();
      /*( <COMMA> t1=readTerm() )**/ tk2 = jj_consume_token(10);
    retval=TermHelper.setAttribute(retval,"__BEGIN_LINE__",tk1.beginLine+lineCorrection_);
    retval=TermHelper.setAttribute(retval,"__END_LINE__",tk2.endLine+lineCorrection_);
    {if (true) return retval;}
      break;
    default:
      jj_la1[38] = jj_gen;
      if (jj_2_8(2)) {
        tk1 = jj_consume_token(16);
        t1 = readTerm();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TWO_DOTS:
        case COMMA:
          t2 = readPatternTail();
          break;
        default:
          jj_la1[36] = jj_gen;
          ;
        }
        tk2 = jj_consume_token(17);
    if (t2==null) {
      termBody=new Term[1];
      termBody[0]=t1;
      retval=createSet(termBody);
    } else if (t2.getName().equals("Pattern")) {
      retval=createSetPattern(t1,t2.getSubtermAt(0));
    }else{
      termBody=new Term[t2.getArity()+1];
      termBody[0]=t1;
      for(int i=0; i<t2.getArity(); ++i){
        termBody[i+1]=t2.getSubtermAt(i);
      }
      retval=createSet(termBody);
    }
    retval=TermHelper.setAttribute(retval,"__BEGIN_LINE__",tk1.beginLine+lineCorrection_);
    retval=TermHelper.setAttribute(retval,"__END_LINE__",tk2.endLine+lineCorrection_);
    retval=TermHelper.setAttribute(retval,"__LINE__",tk1.beginLine+lineCorrection_);
    retval=TermHelper.setAttribute(retval,"__FILE__",fname_);
    {if (true) return retval;}
      } else if (jj_2_9(2)) {
        tk1 = jj_consume_token(16);
        tk2 = jj_consume_token(17);
     retval=createSet(new Term[0]);
     retval=TermHelper.setAttribute(retval,"__BEGIN_LINE__",tk1.beginLine+lineCorrection_);
     retval=TermHelper.setAttribute(retval,"__END_LINE__",tk2.endLine+lineCorrection_);
     retval=TermHelper.setAttribute(retval,"__LINE__",tk1.beginLine+lineCorrection_);
     retval=TermHelper.setAttribute(retval,"__FILE__",fname_);
     {if (true) return retval;}
      } else if (jj_2_10(2)) {
        tk1 = jj_consume_token(11);
        t1 = readTerm();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TWO_DOTS:
        case COMMA:
          t2 = readPatternTail();
          break;
        default:
          jj_la1[37] = jj_gen;
          ;
        }
        tk2 = jj_consume_token(12);
    if (t2==null) {
      termBody=new Term[1];
      termBody[0]=t1;
      retval=createList(termBody);
    } else if (t2.getName().equals("Pattern")) {
      termBody=new Term[2];
      termBody[0]=t1;
      termBody[1]=t2.getSubtermAt(0);
      retval=create("cons",termBody);
    }else{
      termBody=new Term[t2.getArity()+1];
      termBody[0]=t1;
      for(int i=0; i<t2.getArity(); ++i){
        termBody[i+1]=t2.getSubtermAt(i);
      }
      retval=createList(termBody);
    }
    retval=TermHelper.setAttribute(retval,"__BEGIN_LINE__",tk1.beginLine+lineCorrection_);
    retval=TermHelper.setAttribute(retval,"__END_LINE__",tk2.endLine+lineCorrection_);
    retval=TermHelper.setAttribute(retval,"__LINE__",tk1.beginLine+lineCorrection_);
    retval=TermHelper.setAttribute(retval,"__FILE__",fname_);
    {if (true) return retval;}
      } else if (jj_2_11(2)) {
        tk1 = jj_consume_token(11);
        tk2 = jj_consume_token(12);
     retval=TermWare.getInstance().getTermFactory().createNil();
    retval=TermHelper.setAttribute(retval,"__BEGIN_LINE__",tk1.beginLine+lineCorrection_);
    retval=TermHelper.setAttribute(retval,"__END_LINE__",tk2.endLine+lineCorrection_);
    retval=TermHelper.setAttribute(retval,"__LINE__",tk1.beginLine+lineCorrection_);
    retval=TermHelper.setAttribute(retval,"__FILE__",fname_);
    {if (true) return retval;}
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * <code>
 *  scoped_name : <IDENT> ( "::" <IDENT> ) *
 * </code>
 * <br>
 * Example:
 * <pre>
 *   x
 *   x::y
 *   x::y::z
 * </pre>
 *
 **/
  final public Term readScopedName() throws ParseException, TermWareException {
 Token tk1;
 Token tk2;
 Term t=null;
 ArrayList<Term> v = null;
 int endLine=0;
    tk1 = jj_consume_token(IDENT);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TWO_TWO_DOTS:
        ;
        break;
      default:
        jj_la1[39] = jj_gen;
        break label_8;
      }
      jj_consume_token(TWO_TWO_DOTS);
      tk2 = jj_consume_token(IDENT);
                 if (v==null) v=new ArrayList<Term>();
                 v.add(TermWare.getInstance().getTermFactory().createAtom(tk2.image));
                 endLine=tk2.endLine+lineCorrection_;
    }
  Term retval;
  if (v==null) {
    retval=TermWare.getInstance().getTermFactory().createAtom(tk1.image);
    retval=TermHelper.setAttribute(retval,"__BEGIN_LINE__",tk1.beginLine+lineCorrection_);
    retval=TermHelper.setAttribute(retval,"__END_LINE__",tk1.endLine+lineCorrection_);
    retval=TermHelper.setAttribute(retval,"__LINE__",tk1.beginLine+lineCorrection_);
    retval=TermHelper.setAttribute(retval,"__FILE__",fname_);
  } else {
    Term[] nameBody = new Term[v.size()+1];
    nameBody[0]=TermWare.getInstance().getTermFactory().createAtom(tk1.image);
    for(int i=0; i<v.size(); ++i) {
      nameBody[i+1]=v.get(i);
    }
    retval=create("_name",nameBody);
    retval=TermHelper.setAttribute(retval,"__BEGIN_LINE__",tk1.beginLine+lineCorrection_);
    retval=TermHelper.setAttribute(retval,"__END_LINE__",endLine+lineCorrection_);
    retval=TermHelper.setAttribute(retval,"__LINE__",tk1.beginLine+lineCorrection_);
    retval=TermHelper.setAttribute(retval,"__FILE__",fname_);
  }
  {if (true) return retval;}
    throw new Error("Missing return statement in function");
  }

/**
 *<pre>
 * set_tail : ":" term
 *           |
 *             "," term_comma_list
 *</pre>
 *
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTerm
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermCommaList
 **/
  final public Term readPatternTail() throws ParseException, TermWareException {
 Term[] termBody=null;
 Term   t=null;
 Token  tk;
 Term retval;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TWO_DOTS:
      tk = jj_consume_token(TWO_DOTS);
      t = readTerm();
     retval=create("Pattern",t);
     retval=TermHelper.setAttribute(retval,"__BEGIN_LINE__",tk.beginLine+lineCorrection_);
     retval=TermHelper.setAttribute(retval,"__END_LINE__",TermHelper.getAttribute(t,"__END_LINE__"));
     retval=TermHelper.setAttribute(retval,"__LINE__",tk.beginLine+lineCorrection_);
     retval=TermHelper.setAttribute(retval,"__FILE__",fname_);
     {if (true) return retval;}
      break;
    case COMMA:
      tk = jj_consume_token(COMMA);
      termBody = readTermCommaList();
     retval=create("CommaList",termBody);
     retval=TermHelper.setAttribute(retval,"__BEGIN_LINE__",tk.beginLine+lineCorrection_);
     if(termBody.length > 0) {
       retval=TermHelper.setAttribute(retval,"__END_LINE__",TermHelper.getAttribute(termBody[termBody.length-1],"__END_LINE__"));
     }else{
       retval=TermHelper.setAttribute(retval,"__END_LINE__",tk.endLine+lineCorrection_);
     }
     retval=TermHelper.setAttribute(retval,"__LINE__",tk.beginLine+lineCorrection_);
     retval=TermHelper.setAttribute(retval,"__FILE__",fname_);
     {if (true) return retval;}
      break;
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 *<code> x : <X_LITERAL> </code> <br>
 * where <code> <X_LITERAL> </code>  
 * id described by next pattern:
 * <pre>
 * X_LITERAL : "$" (["0"-"9"]|["a"-"z"]|["A"-"Z"]|"_")+ 
 * </pre>
 *<br>
 *Example:
 *<pre>
 *  $x
 *  $myVariable
 *</pre>
 */
  final public Term readX() throws ParseException, TermWareException {
 Token t;
    t = jj_consume_token(X_LITERAL);
   lazyInitXStringIndex();
   Term retval=TermWare.getInstance().getTermFactory().createX(xStringIndex.getIndex(t.image.substring(1)));
   retval=TermHelper.setAttribute(retval,"__BEGIN_LINE__",t.beginLine+lineCorrection_);
   retval=TermHelper.setAttribute(retval,"__END_LINE__",t.endLine+lineCorrection_);
   retval=TermHelper.setAttribute(retval,"__LINE__",t.beginLine+lineCorrection_);
   retval=TermHelper.setAttribute(retval,"__FILE__",fname_);
   {if (true) return retval;}
    throw new Error("Missing return statement in function");
  }

/**
 *<pre> 
 *  term_args : "(" term_comma_list ")" 
 *</pre>
 *<br>
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTermCommaList
 */
  final public Term[] readTermArgs() throws ParseException, TermWareException {
 Term[] args;
    jj_consume_token(9);
    args = readTermCommaList();
    jj_consume_token(10);
    {if (true) return args;}
    throw new Error("Missing return statement in function");
  }

/**
 *<code>
 *  term_comma_list : [  term ( "," term )* ]
 *</code>
 *<br>
 *
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readTerm
 **/
  final public Term[] readTermCommaList() throws ParseException, TermWareException {
 ArrayList<Term> v=new ArrayList<Term>();
 Term t1=null;
 Term t2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 8:
    case 9:
    case 11:
    case 16:
    case TRUE:
    case FALSE:
    case INTEGER_LITERAL:
    case STRING_LITERAL:
    case DOUBLE_LITERAL:
    case NIL:
    case IDENT:
    case X_LITERAL:
    case PLUS:
    case MINUS:
    case LOGICAL_NOT:
    case BIT_NEGATE:
    case DOT:
    case NAMPERSAND:
      t1 = readTerm();
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[41] = jj_gen;
          break label_9;
        }
        jj_consume_token(COMMA);
        t2 = readTerm();
                    v.add(t2);
      }
      break;
    default:
      jj_la1[42] = jj_gen;
      ;
    }
  if (t1==null) {if (true) return new Term[0];}
  Term[] retval = new Term[v.size()+1];
  retval[0]=t1;
  for(int i=0; i<v.size(); ++i) {
    retval[i+1]=v.get(i);
  }
  {if (true) return retval;}
    throw new Error("Missing return statement in function");
  }

/**
 *<pre>
 * primitive: string | integer | double | boolean | nil
 *</pre>
 *<br>
 *  
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readString
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readInteger
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readDouble
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readBoolean
 *@see ua.gradsoft.termware.parsers.terms.TermReader#readNIL
 **/
  final public Term readPrimitive() throws ParseException, TermWareException {
 Term retval;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      retval = readString();
     {if (true) return retval;}
      break;
    case INTEGER_LITERAL:
      retval = readInteger();
     {if (true) return retval;}
      break;
    case DOUBLE_LITERAL:
      retval = readDouble();
     {if (true) return retval;}
      break;
    case TRUE:
    case FALSE:
      retval = readBoolean();
     {if (true) return retval;}
      break;
    case NIL:
      retval = readNIL();
     {if (true) return retval;}
      break;
    default:
      jj_la1[43] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 *<code> string: <STRING_LITERAL> </code>
 *<br>
 * where STRING_LITERAL described by next regular expression:
 *<pre>
 *  STRING_LITERAL : "\""
 *  ( ( ~["\"","\\"])
 *  | ("\\" (
 *            ["n","t","v","b","r","f","\\","'","\""]
 *           |
 *            "0" (["0"-"7"])*
 *           |
 *            ["1"-"9"] (["0"-"9"])*
 *           |
 *            ("0x" | "0X") (["0"-"9","a"-"f","A"-"F"])+
 *          )
 *    )
 *  )*
 *  "\"" 
 *</pre>
 * i. e. "C-like" string.
 **/
  final public Term readString() throws ParseException, TermWareException {
 Token t;
    t = jj_consume_token(STRING_LITERAL);
    Term retval=TermWare.getInstance().getTermFactory().createString(TermReaderUtils.token2String(t.image));
    retval=TermHelper.setAttribute(retval,"__BEGIN_LINE__",t.beginLine+lineCorrection_);
    retval=TermHelper.setAttribute(retval,"__END_LINE__",t.endLine+lineCorrection_);
    retval=TermHelper.setAttribute(retval,"__LINE__",t.beginLine+lineCorrection_);
    retval=TermHelper.setAttribute(retval,"__FILE__",fname_);
    {if (true) return retval;}
    throw new Error("Missing return statement in function");
  }

/**
 *<code>
 * integer : <INTEGER_LITERAL>
 *<code>
 *<br>
 *<code>
 * INTEGER_LITERAL: (["0"-"9"])+("L"|"B")?
 *</code> 
 **/
  final public Term readInteger() throws ParseException, TermWareException {
 Token t;
    t = jj_consume_token(INTEGER_LITERAL);
   Term retval=null;
   if (t.image.endsWith("B")) {
      //BigInteger  
      String s = t.image.substring(0,t.image.length()-1);
      try {
        BigInteger bi=new BigInteger(s);
        retval=TermWare.getInstance().getTermFactory().createBigInteger(bi);
      }catch(NumberFormatException ex){
        {if (true) throw new TermParseException("Can't parse "+s+" to big integer",ex);}
      }
   } else if (t.image.endsWith("L")) {
      // Long
      String s = t.image.substring(0,t.image.length()-1);
      long l = 0;
      try {
        l=Long.parseLong(s);
      }catch(NumberFormatException ex){
        {if (true) throw new TermParseException("Can't parse "+s+" to long",ex);}
      }
      retval=TermWare.getInstance().getTermFactory().createLong(l);
   } else {
      int x=0;
      try {
         x=Integer.parseInt(t.image,10);
      }catch(NumberFormatException ex){
          {if (true) throw new TermParseException("Can't parse "+t.image+" to int",ex);}
      }
      retval=TermWare.getInstance().getTermFactory().createInt(x);
   }
   retval=TermHelper.setAttribute(retval,"__BEGIN_LINE__",t.beginLine+lineCorrection_);
   retval=TermHelper.setAttribute(retval,"__END_LINE__",t.endLine+lineCorrection_);
   retval=TermHelper.setAttribute(retval,"__LINE__",t.beginLine+lineCorrection_);
   retval=TermHelper.setAttribute(retval,"__FILE__",fname_);
   {if (true) return retval;}
    throw new Error("Missing return statement in function");
  }

/**
 *<code>
 * double : <DOUBLE_LITERAL>
 *</code>
 *<br>
 **/
  final public Term readDouble() throws ParseException, TermWareException {
 Token t;
    t = jj_consume_token(DOUBLE_LITERAL);
   Term retval=null;
   if (t.image.endsWith("B")) {
     String s = t.image.substring(0,t.image.length()-1);
     try {
       BigDecimal bd = new BigDecimal(s);
       retval=TermWare.getInstance().getTermFactory().createBigDecimal(bd);
     }catch(NumberFormatException ex){
       {if (true) throw new TermParseException("Can't parse "+t.image+" as big decimal",ex);}
     }
   }else if (t.image.endsWith("F")) {
     float x=0.0F;
     try {
       x=Float.parseFloat(t.image);
     }catch(NumberFormatException ex){
       {if (true) throw new TermParseException("Can't parse "+t.image+" as float",ex);}
     }
     retval=TermWare.getInstance().getTermFactory().createFloat(x);
   }else{
     double x=0.0;
     try {
       x=Double.parseDouble(t.image);
     }catch(NumberFormatException ex){
       {if (true) throw new TermParseException("Can't parse "+t.image+" as double",ex);}
     }
     retval=TermWare.getInstance().getTermFactory().createDouble(x);
   }
   retval=TermHelper.setAttribute(retval,"__BEGIN_LINE__",t.beginLine+lineCorrection_);
   retval=TermHelper.setAttribute(retval,"__END_LINE__",t.endLine+lineCorrection_);
   retval=TermHelper.setAttribute(retval,"__LINE__",t.beginLine+lineCorrection_);
   retval=TermHelper.setAttribute(retval,"__FILE__",fname_);
   {if (true) return retval;}
    throw new Error("Missing return statement in function");
  }

/**
 * <code>
 * boolean: "true" | "false"
 * </code>
 **/
  final public Term readBoolean() throws ParseException, TermWareException {
 Term retval;
 Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
      t = jj_consume_token(TRUE);
      retval=TermWare.getInstance().getTermFactory().createBoolean(true);
      break;
    case FALSE:
      t = jj_consume_token(FALSE);
      retval=TermWare.getInstance().getTermFactory().createBoolean(false);
      break;
    default:
      jj_la1[44] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
   retval=TermHelper.setAttribute(retval,"__BEGIN_LINE__",t.beginLine+lineCorrection_);
   retval=TermHelper.setAttribute(retval,"__END_LINE__",t.endLine+lineCorrection_);
   retval=TermHelper.setAttribute(retval,"__LINE__",t.beginLine+lineCorrection_);
   retval=TermHelper.setAttribute(retval,"__FILE__",fname_);
   {if (true) return retval;}
    throw new Error("Missing return statement in function");
  }

/**
 *<code>
 * nil: "NIL"
 *</code>
 */
  final public Term readNIL() throws ParseException, TermWareException {
 Token t;
    t = jj_consume_token(NIL);
    Term retval=TermWare.getInstance().getTermFactory().createNIL();
    retval=TermHelper.setAttribute(retval,"__BEGIN_LINE__",t.beginLine+lineCorrection_);
    retval=TermHelper.setAttribute(retval,"__END_LINE__",t.endLine+lineCorrection_);
    retval=TermHelper.setAttribute(retval,"__LINE__",t.beginLine+lineCorrection_);
    retval=TermHelper.setAttribute(retval,"__FILE__",fname_);
    {if (true) return retval;}
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  final private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  final private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  final private boolean jj_3R_53() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(33)) {
    jj_scanpos = xsp;
    if (jj_scan_token(34)) return true;
    }
    return false;
  }

  final private boolean jj_3R_56() {
    if (jj_3R_62()) return true;
    return false;
  }

  final private boolean jj_3R_65() {
    if (jj_scan_token(NIL)) return true;
    return false;
  }

  final private boolean jj_3R_52() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_55()) {
    jj_scanpos = xsp;
    if (jj_3R_56()) {
    jj_scanpos = xsp;
    if (jj_3R_57()) {
    jj_scanpos = xsp;
    if (jj_3R_58()) {
    jj_scanpos = xsp;
    if (jj_3R_59()) return true;
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_55() {
    if (jj_3R_61()) return true;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_scan_token(11)) return true;
    if (jj_3R_12()) return true;
    return false;
  }

  final private boolean jj_3_11() {
    if (jj_scan_token(11)) return true;
    if (jj_scan_token(12)) return true;
    return false;
  }

  final private boolean jj_3R_33() {
    if (jj_3R_36()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_75()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_73() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  final private boolean jj_3R_12() {
    if (jj_3R_24()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_34()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_72() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  final private boolean jj_3R_68() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  final private boolean jj_3R_67() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  final private boolean jj_3R_69() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_72()) {
    jj_scanpos = xsp;
    if (jj_3R_73()) return true;
    }
    return false;
  }

  final private boolean jj_3R_64() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_67()) {
    jj_scanpos = xsp;
    if (jj_3R_68()) return true;
    }
    return false;
  }

  final private boolean jj_3R_38() {
    if (jj_3R_42()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_53()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_49() {
    if (jj_scan_token(BIT_AND)) return true;
    return false;
  }

  final private boolean jj_3_10() {
    if (jj_scan_token(11)) return true;
    if (jj_3R_10()) return true;
    return false;
  }

  final private boolean jj_3R_74() {
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_scan_token(9)) return true;
    if (jj_3R_11()) return true;
    return false;
  }

  final private boolean jj_3_9() {
    if (jj_scan_token(16)) return true;
    if (jj_scan_token(17)) return true;
    return false;
  }

  final private boolean jj_3R_27() {
    if (jj_scan_token(8)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3R_31()) return true;
    }
    return false;
  }

  final private boolean jj_3R_50() {
    if (jj_3R_54()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_69()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_78() {
    if (jj_scan_token(9)) return true;
    return false;
  }

  final private boolean jj_3R_11() {
    if (jj_3R_23()) return true;
    if (jj_scan_token(15)) return true;
    return false;
  }

  final private boolean jj_3R_35() {
    if (jj_3R_38()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_49()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_30() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(50)) jj_scanpos = xsp;
    if (jj_3R_33()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_74()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_22() {
    if (jj_3R_28()) return true;
    return false;
  }

  final private boolean jj_3_8() {
    if (jj_scan_token(16)) return true;
    if (jj_3R_10()) return true;
    return false;
  }

  final private boolean jj_3R_21() {
    if (jj_3R_27()) return true;
    return false;
  }

  final private boolean jj_3R_10() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_21()) {
    jj_scanpos = xsp;
    if (jj_3R_22()) return true;
    }
    return false;
  }

  final private boolean jj_3R_63() {
    if (jj_scan_token(DOUBLE_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_76() {
    if (jj_3R_78()) return true;
    return false;
  }

  final private boolean jj_3R_23() {
    if (jj_scan_token(X_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_71() {
    if (jj_scan_token(RIGHT_SHIFT)) return true;
    return false;
  }

  final private boolean jj_3R_48() {
    if (jj_scan_token(9)) return true;
    if (jj_3R_10()) return true;
    return false;
  }

  final private boolean jj_3R_70() {
    if (jj_scan_token(LEFT_SHIFT)) return true;
    return false;
  }

  final private boolean jj_3R_47() {
    if (jj_3R_23()) return true;
    return false;
  }

  final private boolean jj_3R_66() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) return true;
    }
    return false;
  }

  final private boolean jj_3R_46() {
    if (jj_3R_52()) return true;
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_scan_token(11)) return true;
    if (jj_3R_12()) return true;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_3R_10()) return true;
    if (jj_scan_token(7)) return true;
    return false;
  }

  final private boolean jj_3R_26() {
    if (jj_3R_30()) return true;
    return false;
  }

  final private boolean jj_3R_32() {
    if (jj_3R_35()) return true;
    return false;
  }

  final private boolean jj_3R_41() {
    if (jj_scan_token(LOGICAL_AND)) return true;
    return false;
  }

  final private boolean jj_3R_43() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_45()) {
    jj_scanpos = xsp;
    if (jj_3R_46()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) {
    jj_scanpos = xsp;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3_8()) {
    jj_scanpos = xsp;
    if (jj_3_9()) {
    jj_scanpos = xsp;
    if (jj_3_10()) {
    jj_scanpos = xsp;
    if (jj_3_11()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_45() {
    if (jj_3R_51()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_76()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_44() {
    if (jj_3R_50()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_66()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_scan_token(11)) return true;
    if (jj_3R_12()) return true;
    return false;
  }

  final private boolean jj_3R_62() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_16() {
    if (jj_scan_token(8)) return true;
    return false;
  }

  final private boolean jj_3R_29() {
    if (jj_3R_32()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_41()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_25() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_scan_token(43)) {
    jj_scanpos = xsp;
    if (jj_scan_token(48)) {
    jj_scanpos = xsp;
    if (jj_scan_token(49)) return true;
    }
    }
    }
    if (jj_3R_54()) return true;
    return false;
  }

  final private boolean jj_3R_20() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_25()) {
    jj_scanpos = xsp;
    if (jj_3R_26()) return true;
    }
    return false;
  }

  final private boolean jj_3R_15() {
    if (jj_scan_token(13)) return true;
    if (jj_scan_token(9)) return true;
    return false;
  }

  final private boolean jj_3R_37() {
    if (jj_scan_token(LOGICAL_OR)) return true;
    return false;
  }

  final private boolean jj_3R_40() {
    if (jj_3R_43()) return true;
    return false;
  }

  final private boolean jj_3R_14() {
    if (jj_scan_token(11)) return true;
    if (jj_3R_12()) return true;
    return false;
  }

  final private boolean jj_3R_60() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(35)) {
    jj_scanpos = xsp;
    if (jj_scan_token(36)) {
    jj_scanpos = xsp;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(38)) {
    jj_scanpos = xsp;
    if (jj_scan_token(39)) {
    jj_scanpos = xsp;
    if (jj_scan_token(25)) return true;
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_61() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_19() {
    if (jj_scan_token(MOD)) return true;
    return false;
  }

  final private boolean jj_3R_13() {
    if (jj_scan_token(8)) return true;
    if (jj_scan_token(9)) return true;
    return false;
  }

  final private boolean jj_3R_18() {
    if (jj_scan_token(DIVIDE)) return true;
    return false;
  }

  final private boolean jj_3R_77() {
    if (jj_scan_token(TWO_TWO_DOTS)) return true;
    return false;
  }

  final private boolean jj_3_6() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_13()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_14()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_15()) jj_scanpos = xsp;
    if (jj_scan_token(LEFT_ARROW)) return true;
    xsp = jj_scanpos;
    if (jj_3R_16()) jj_scanpos = xsp;
    if (jj_3R_12()) return true;
    return false;
  }

  final private boolean jj_3R_17() {
    if (jj_scan_token(MULTIPLY)) return true;
    return false;
  }

  final private boolean jj_3_7() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_17()) {
    jj_scanpos = xsp;
    if (jj_3R_18()) {
    jj_scanpos = xsp;
    if (jj_3R_19()) return true;
    }
    }
    if (jj_3R_20()) return true;
    return false;
  }

  final private boolean jj_3R_28() {
    if (jj_3R_12()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_6()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_31() {
    if (jj_3R_10()) return true;
    return false;
  }

  final private boolean jj_3R_24() {
    if (jj_3R_29()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_37()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_51() {
    if (jj_scan_token(IDENT)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_77()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_42() {
    if (jj_3R_44()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_60()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_39() {
    if (jj_scan_token(NAMPERSAND)) return true;
    if (jj_scan_token(IDENT)) return true;
    return false;
  }

  final private boolean jj_3R_36() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_39()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_40()) return true;
    return false;
  }

  final private boolean jj_3R_75() {
    if (jj_scan_token(ARGS_DOTS)) return true;
    return false;
  }

  final private boolean jj_3R_59() {
    if (jj_3R_65()) return true;
    return false;
  }

  final private boolean jj_3R_34() {
    if (jj_scan_token(QUESTION)) return true;
    return false;
  }

  final private boolean jj_3R_58() {
    if (jj_3R_64()) return true;
    return false;
  }

  final private boolean jj_3R_57() {
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_54() {
    if (jj_3R_20()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_7()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  public TermReaderTokenManager token_source;
  JavaCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[45];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_0();
      jj_la1_1();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0xd7d0b01,0xd7d0b00,0xd7d0b00,0x100,0x800,0x2000,0x100,0x2000,0x80000000,0x100,0x2000,0x100,0x2000,0x4000,0x2000,0x0,0x0,0x20000000,0x40000000,0x0,0x0,0x0,0x2000000,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0xd7d0a00,0x0,0x0,0x0,0x0,0x200,0x0,0x0,0xd7c0200,0x0,0x0,0x0,0xd7d0b00,0x17c0000,0xc0000,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x1070c00,0x1070c00,0x1070c00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x200000,0x0,0x0,0x1,0x6,0x6,0xf8,0xf8,0x300,0x300,0xc00,0xc00,0xb000,0x30c00,0x1070c00,0x40000,0x40000,0x800000,0x1000000,0x0,0x180000,0x180000,0x0,0x400000,0x180000,0x100000,0x1070c00,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[11];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public TermReader(InputStream stream) {
     this(stream, null);
  }
  public TermReader(InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new TermReaderTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 45; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 45; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public TermReader(Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new TermReaderTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 45; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 45; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public TermReader(TermReaderTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 45; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(TermReaderTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 45; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private Vector jj_expentries = new Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[57];
    for (int i = 0; i < 57; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 45; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 57; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 11; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
